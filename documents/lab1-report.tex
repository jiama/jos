\documentclass[10pt]{article}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{everb}
\pagestyle{plain}
%End of latex macro

\begin{document}

\lstset{ basicstyle=\small,
	escapeinside=``,
	keywordstyle=\color{red} \bfseries,% \underbar,
	identifierstyle={},
	commentstyle=\color{blue},
	stringstyle=\ttfamily,
	%labelstyle=\tiny,
	extendedchars=false,
	linewidth=\textwidth,
	numbers=left,
	numberstyle=\tiny \color{blue},
	frame=trbl
}

\title{JOS Lab1: Booting a PC}
\author{Just for Fun}
\maketitle
\thispagestyle{empty}

\begin{abstract}
This is the report for \emph{MIT 6.828 Fall 2012 Lab 1: Booting a PC.}
\end{abstract}

\section{Preparation}
	\subsection{Introduction}
		Nothing to say.
	
	\subsection{Software Setup}
		I used Debian(at home) and Redhat(home). They both already have all the required softwares, at least RPMs or DEBs. One of my classmates tried to use MacOS X and got a lot of trouble.
	
	\subsection{Hand-In Procedue}
		I keep my codes at Github.com, which is a greate platform. Do not ever forget to backup your codes. Here are some usef commands you might want to use:

\begin{lstlisting}
athena% git remote add $repo-name $repo-url
athena% git pull $repo-name
athena% git push $repo-name $local-branch:$remote-branch
\end{lstlisting}

\section{Part 1: PC Bootstrap}
	\subsection{Getting Started with x86 assembly}
		\begin{quote}\begin{colorboxed}
		Exercise 1. Familiarize yourself with the assembly language materials available on the 6.828 reference page. You don't have to read them now, but you'll almost certainly want to refer to some of this material when reading and writing x86 assembly.

		We do recommend reading the section "The Syntax" in Brennan's Guide to Inline Assembly. It gives a good (and quite brief) description of the AT\&T assembly syntax we'll be using with the GNU assembler in JOS. 
		\end{colorboxed}\end{quote}
		\begin{flushleft}
		You may find that the documents given are too long to read. There is actually no need to read those documents. Most of the assembly codes are easy to read and understand, and there are many chances for us to read and write simple those kinds of codes in the later labs.
		But I suggest Brennan's Guide. This is something important and you should know.
		\end{flushleft}

	\subsection{Simulating the x86}
		\begin{flushleft}
		QEMU is a great software. Read GNUMakefile and you will get most of what the web page is talking about.
		\end{flushleft}

	\subsection{The PC's Physical Address Space}
		\begin{flushleft}
		The most interesting thing I found is that some students do not know about the exact definition of \emph{Physical Address Space}. I think you will get it if you do your own job.
		\end{flushleft}

	\subsection{The ROM BIOS}
		\begin{quote}\begin{colorboxed}
		Exercise 2. Use GDB's si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at Phil Storrs I/O Ports Description, as well as other materials on the 6.828 reference materials page. No need to figure out all the details - just the general idea of what the BIOS is doing first.
		\end{colorboxed}\end{quote}
		\begin{flushleft}
		Trust me. This part is important, especially for those who have not used GDB yet. This is offering you the chance to practise using it. And you should really be familiar with how to calculate address in different situations. MM is thought to be the most difficult part and yes, it really is in modern systems.
		\end{flushleft}

\section{Part 2: The Boot Loader}
	\begin{quote}	
	\begin{colorboxed}
	Exercise 3. Take a look at the lab tools guide, especially the section on GDB commands. Even if you're familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.

	Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot/boot.S, using the source code and the disassembly file obj/boot/boot.asm to keep track of where you are. Also use the x/i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj/boot/boot.asm and GDB.

	Trace into bootmain() in boot/main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader. 
	\end{colorboxed}
	\end{quote}

	\begin{flushleft}	
	\emph{\large{Question:}}
		\begin{quote}
		At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?
		\end{quote}
	\end{flushleft}
	\emph{\large{Answer:}}\newline
\begin{lstlisting}[language={[x86masm]Assembler}]
# Switch from real to protected mode, using a bootstrap GDT
# and segment translation that makes virtual addresses 
# identical to their physical addresses, so that the 
# effective memory map does not change during the switch.
lgdt    gdtdesc
movl    %cr0, %eax
orl     $CR0_PE_ON, %eax
movl    %eax, %cr0
\end{lstlisting}	

	\begin{flushleft}	
	\emph{\large{Question:}}
		\begin{quote}
		What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?
		\end{quote}
	\end{flushleft}
	\emph{\large{Answer:}}\newline
\begin{lstlisting}[language={[x86masm]Assembler}]
// call the entry point from the ELF header
// note: does not return!
((void (*)(void)) (ELFHDR->e_entry))();
\end{lstlisting}

	\begin{flushleft}	
	\emph{\large{Question:}}
		\begin{quote}
		Where is the first instruction of the kernel?
		\end{quote}
	\end{flushleft}
	\emph{\large{Answer:}}\newline
\begin{lstlisting}[language={[x86masm]Assembler}]
.globl entry
entry:
	movw	$0x1234,0x472	# warm boot
\end{lstlisting}

	\begin{flushleft}	
	\emph{\large{Question:}}
		\begin{quote}
		How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?
		\end{quote}
	\end{flushleft}
	\emph{\large{Answer:}}\newline
\begin{lstlisting}[language=C]
// load each program segment (ignores ph flags)
ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
eph = ph + ELFHDR->e_phnum;
for (; ph < eph; ph++)
	// p_pa is the load address of this segment (as well
	// as the physical address)
	readseg(ph->p_pa, ph->p_memsz, ph->p_offset);
\end{lstlisting}

	\subsection{Loading the Kernel}
	\begin{quote}	
	\begin{colorboxed}
	Exercise 4. Read about programming with pointers in C. The best reference for the C language is The C Programming Language by Brian Kernighan and Dennis Ritchie (known as 'K&R'). We recommend that students purchase this book (here is an Amazon Link) or find one of MIT's 7 copies.

	Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&R. Then download the code for pointers.c, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in lines 1 and 6 come from, how all the values in lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.

	There are other references on pointers in C, though not as strongly recommended. A tutorial by Ted Jensen that cites K&R heavily is available in the course readings.

	Warning: Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don't want to find out what "the hard way" is. 
	\end{colorboxed}
	\end{quote}

	\begin{flushleft}
		This is quite basic but very very confusing and important.
	\end{flushleft}

	\begin{quote}	
	\begin{colorboxed}
	Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would "break" or otherwise do the wrong thing if you were to get the boot loader's link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don't forget to change the link address back and make clean again afterward!
	\end{colorboxed}
	\end{quote}

	\begin{flushleft}
		
	\end{flushleft}

\end{document}

